ğŸ¯ Purpose: Anonymous, ephemeral peer-to-peer chat using shared room codes. Supports text, images, and video file sharing with no user accounts or backend storage.

ğŸ§  BACKEND (Coordination + Signaling Layer)
Build a lightweight, stateless backend that only handles room creation, peer discovery, and signaling for P2P connections. No user data, no media storage.

ğŸ§± Backend Responsibilities:
REST API for creating/joining rooms

WebSocket-based signaling relay (for offer/answer/ICE)

In-memory room state (no DB)

Expire empty/inactive rooms (after 5 minutes)

No media routing or persistence â€” strictly signaling layer

ğŸ”§ REST API
POST /create-room
Response: { roomId: string }

Creates short room ID, initializes memory state

POST /join-room
Body: { roomId: string, clientId: string }

Response: { peers: string[] }

Adds client to room, returns peer list

ğŸ” WebSocket Protocol
On connection: { type: "init", roomId, clientId }

Relay signaling messages:

{ type: "offer" | "answer" | "ice-candidate", from, to, payload }

Notify others on disconnect:

{ type: "peer-left", clientId }

ğŸ” Security & Hygiene
Validate message formats

Sanitize input

Rate-limit WS traffic

No user tracking, no cookies, no logging

âš ï¸ Optional:

If P2P fails due to network restrictions, optionally support temporary in-memory message relay with auto-expiry (e.g., 60s buffer max)

ğŸ“± FRONTEND (iOS App) â€” Anonymous P2P Chat with File & Video Sharing
Build a Swift-based iOS app that allows users to connect via room ID and communicate directly P2P using WebRTC or MultipeerConnectivity.

No backend chat storage. No profiles. No auth. Everything is ephemeral.

ğŸ§­ User Flow
Create Room â†’ calls /create-room â†’ receives roomId

Join Room â†’ enters roomId â†’ connects to WebSocket + peers

App creates a mesh of peer connections and opens DataChannels

ğŸ’¬ Supported Communication
Once connected, users can exchange:

âœ… Text Messages

ğŸ–¼ï¸ Images (base64 or binary chunks)

ğŸï¸ Pre-recorded video files (e.g., MP4, MOV)

ğŸ”„ Video File Sending:
ğŸ“¦ Use WebRTC DataChannel or MultipeerConnectivity to transfer full video files peer-to-peer:

WebRTC DataChannel Approach:
Select a video (from Files or Photos)

Chunk into 16â€“32KB segments

Send each chunk over DataChannel

Reassemble and write on receiving side

Example (Swift pseudocode):

swift
Copy
Edit
let chunkSize = 16000
let fileData = try Data(contentsOf: fileURL)
for offset in stride(from: 0, to: fileData.count, by: chunkSize) {
    let chunk = fileData.subdata(in: offset..<min(offset + chunkSize, fileData.count))
    dataChannel.sendData(RTCDataBuffer(data: chunk, isBinary: true))
}
MultipeerConnectivity (for local P2P):
Use Apple's native APIs to send files in full

Less control, but simpler for LAN/nearby devices

ğŸ¨ UI Requirements
Minimalist, modern dark-mode interface

Components:

Create/join room screens

Chat view (text/images/videos)

File picker & preview

Peer list / connection status

Show when a peer joins or leaves

Progress bar for file/video transfer

Warning: leaving app = session lost

ğŸ“² Performance & UX Considerations
Feature	Requirement
Live chat	Low-latency via DataChannel
File/image	Handle chunks, show preview
Video	Chunked P2P transfer, preview on receiver
Error handling	Show reconnect prompts
Storage	RAM only â€” no disk persistence
Encryption	WebRTC/MPC secure by default

ğŸ§ª QA Checklist
Test file + video transfer across devices

Confirm correct reassembly and preview

Stress test multiple peers

Confirm room expiry logic

Gracefully handle disconnects and backgrounding